#This file contains helper functions

define SegBoundary [[" " | .#.] (["@"|"#"])]; #Segments end on a space (or the end of input)
define GroupBoundary [",@" | ",#" | SegBoundary];
define UnitBoundary GroupBoundary;
define VowelUnitStartL [",@"|"@"];
define ConsUnitStartL [",#"|"#"];

define VowelAnt ["\pln"|"\nat"|"\brd"|"\clr"|"\ctr"|"\iot"|"\rnd"|"\opq"|"\idp"|"\udp"];
define ConsonantAnt ["\co"|"\vo"|"\no"|"\svo"|"\sno"|"\hvo"|"\hno"|"\w"|"\y"];

define Ant ["\si"|"\st"|"\stst"|"\sel"|"\ser"|"\selr"|"\serl"|"\se"|"\sch"|VowelAnt|ConsonantAnt]; #All possible annotations after preprocessing

#Recall that we have transformed nested annotations for stresses to the following
#\brd{\st{a}} -> \brd${a}, \brd{\stst{a}} -> \brd$${a}

define StressMarker     ["$"|"$$"];
define WithAnt(AN, X)   [AN (StressMarker) "{" X "}"]; #only X with annotation AN applied
define EAnt(AN)         WithAnt(AN, 0); #Empty annotation AN
define AnyAnt(X)        [WithAnt(Ant, X) | X]; #X with any annotation applied
define AnyAntL(X)       [X ("}")]; #X possibly with an annotation on the left
define AnyAntR(X)       [([Ant (StressMarker) "{"]) X]; #X possibly with an annotation on the right
define NotInAntL        ["}" | GroupBoundary] [\Ant & \StressMarker]*; #on LHS of match, ensures that we're not matching within an annotation
define NotInAntR        [\"}"]* [Ant | StressMarker | GroupBoundary]; #on RHS of match, ensures that we're not matching within an annotation

#this guy is needed because WithAnt() on RHS of replace rule creates ambiguity
define WithAntR(AN, X)  [AN "{" X "}"];

define EarlyConsonant    [b|c|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|w|x|y|z];
define EarlyVowel        [a|e|i|o|u];

define Alphabet         [EarlyConsonant | EarlyVowel | Ant | "{" | "}" | "@" | "#" | "$" | "$$" | SegBoundary | GroupBoundary | "-" | "'" | "<-" | "<<-" | "->" | "->>"];

